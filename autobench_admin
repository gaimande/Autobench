#!/usr/bin/perl -w

# autobench_admin - command line administration tool for distributed autobench

# Copyright (C) 2002 - 2003 Julian T. J. Midgley <jtjm@xenoclast.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# A copy of version 2 of the GNU General Public License may be found
# in the file "LICENCE" in the Autobench tarball.

use strict;
use Socket;
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Getopt::Long;
use FileHandle;
use POSIX qw(strftime);
use LWP::Simple;

# The location of the master config file
my $MASTER_CONFIG = "/etc/autobench.conf";

# The location of the autobench config file
my $CONFIG_FILE = $ENV{HOME}."/.autobench.conf";

my $DEBUG = 0;

my $VERSION = "2.1.1";

my (%clients, $httperf_args, $curr_rate, %res_host, %res_host1, %res_host2, $dem_req);
my ($sep, $client, $num_clients, $key);

#--------------------------------------------------------------------------
# wait_stable([$config_file])
#
# Delay time to make server stable before the next test.
#

sub
wait_stable
{
	my ($server, $time_gap) = @_;
	my $CPU_LOAD_SAFE = 2.0;
	my $wait_check_time = 2;
	my $url = "http://$server:19999".
		      "/api/v1/data?chart=system.cpu".
			  "&after=-$time_gap&before=0&group=average".
			  "&options=absolute&points=1&format=ssv";
	
	if (!get $url) {
		# If cannot get server cpu load information, just sleep
		print STDERR "Waiting $time_gap seconds before the next test...\n";
        sleep ($time_gap);
    }
	else
	{
		my $curr_cpu_load;

		print STDERR "Waiting server $server stable before the next test...\n";
		while (($curr_cpu_load = get $url) > $CPU_LOAD_SAFE)
		{
			print "System is not safe ($curr_cpu_load). Wait $wait_check_time seconds to check again.\n" if $DEBUG;
			sleep $wait_check_time;
		}

		print "System is safe ($curr_cpu_load).\n" if $DEBUG;
	}
}

#--------------------------------------------------------------------------
# get_config([$config_file])
#
# Reads the config file ($CONFIG_FILE), and returns the configuration
# as a hash.

sub
get_config
{
    my $CONFIG_FILE = shift @_; # optional - overrides $CONFIG_FILE if present
    my %config;
    my $install = 0;

    open (IN,$CONFIG_FILE) 
    or $install = 1;

    if ($install) {
    install_new_config($CONFIG_FILE);
    print STDERR "Installation complete - please rerun autobench_admin\n";
    exit(0);
    }
    
    while (<IN>) {
    # Throw away comments and blank lines
    next if (/^\#.*|^\s+$|^\s+\#|^$/);
    
    # Check for valid key-value pair and extract key into $1, value into $2
    unless (/^\s*([a-zA-Z][a-zA-Z_0-9\-]*?)\s*=\s*(\S.*?)\s*$/) {
        warn "AUTOBENCH: Warning - invalid line in config file:'$_'";
        next;
    }
    
    if (defined $config{$1}) {
        warn "AUTOBENCH: Warning - parameter '$1' defined more than once,".
         "ignoring '$1'='$2'";
        next;
    }
    $config{$1}=$2;
    }
    return %config;
}

#--------------------------------------------------------------------------
# install_new_config($dest)
# 
# Installs a copy of the autobench config file into a user's home directory

sub
install_new_config
{
    my $dest = shift @_;
    print STDERR "Autobench configuration file not found\n - installing new copy in $dest\n";
    system("cp $MASTER_CONFIG $dest");
}

#---------------------------------------------------------------------------
# get_clients ($clients)
sub
get_clients
{
    my $clients = shift @_;
    my @tmp_clients = split(/,/,$clients);
    my ($host, %client_hash, $port, $str);

    foreach $str (@tmp_clients) {
    ($host, $port)      = split(/:/,$str);
    $client_hash{$host} = $port;
    }
    return \%client_hash;
}

#---------------------------------------------------------------------------
# open_socket($host, $port)
sub
open_socket
{
    my ($host, $port) = @_;
    my $iaddr = inet_aton($host)
    or die "Invalid host: $host: $!";
    my $paddr;

    my $sock = new FileHandle;
    socket ($sock, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
    $paddr = sockaddr_in($port, $iaddr);
    connect($sock, $paddr)
    or die "Connection to $host:$port failed: $!";
    return $sock;
}
        
#---------------------------------------------------------------------------
# set_non_block ($fh)
sub
set_non_block
{
    my $fh = shift @_;
    my $flags = fcntl($fh, F_GETFL, 0)
    or die "Can't get flags for socket: $!\n";
    $flags = fcntl($fh, F_SETFL, $flags | O_NONBLOCK)
    or die "Can't set flags for socket: $!\n";
}

#---------------------------------------------------------------------------
# build_select_bits (@socks)

sub
build_select_bits
{
    my @socks = @_;
    my ($sock, $selbits);
    $selbits = '';

    foreach $sock (@socks) {
    vec($selbits, fileno($sock), 1) = 1;
    }
    
    return $selbits;
}

#---------------------------------------------------------------------------
# gen_rand_serial ()

sub
gen_rand_serial
{
    my @chars = ("A".."Z");
    my $string;

    $string .= $chars[rand @chars] for 1..8;

    return $string;
}

#---------------------------------------------------------------------------
# parse_response ($response)

sub
parse_response
{
    my $response = shift @_;
    my @elements = split(/\n/, $response);
    my ($el, %results, $key, $val);

    foreach $el (@elements) {
    next if ($el =~ /BENCH_COMPLETE|END_DATA/);
    ($key, $val) = split(/::/, $el);
    $results{$key} = $val;
    }
    return \%results;
}

#---------------------------------------------------------------------------
# collate_results($results_sock_ref, @socks)
sub
collate_results
{
    my ($results_sock_ref, @socks) = @_;
    my ($sock, $key, %results);
    my $num_clients = @socks;

    foreach $sock (@socks) {
    foreach $key (keys %{$$results_sock_ref{$sock}}) {
		if ($key eq "duration")
		{
			if (!defined($results{$key}) || $results{$key} < ${$$results_sock_ref{$sock}}{$key}) {
				$results{$key} = ${$$results_sock_ref{$sock}}{$key};
			}
		}
		elsif ($key cmp "time_begin" && $key cmp "time_end") {
			$results{$key} += ${$$results_sock_ref{$sock}}{$key};
		}
    }
    }

    $results{time_begin} = ${$$results_sock_ref{$socks[0]}}{time_begin};
    $results{time_end} = ${$$results_sock_ref{$socks[0]}}{time_end};
    $results{sess_life_time} = $results{sess_life_time} / $num_clients;
	$results{net_io} = $results{net_io} / $num_clients;
    
    return \%results;
}

    
#---------------------------------------------------------------------------
# run_test($httperf_args, $clients_ref, $config_ref)
sub
run_test
{
    my ($httperf_args, $clients_ref, $config_ref) = @_;
    my ($client, %client_socks, @socks, $sock, %response, %results_sock);
    my ($rin, $rout, $buffer, $bytes, $nfound, $accepted, $completed, $httperf_args_full);
    my @serial_prefix_lists;
    my $i = 0;

	if (!defined($$config_ref{serial_prefix})) {
    	foreach $client (keys %$clients_ref) {
			push (@serial_prefix_lists, gen_rand_serial);
    	}
		print STDERR "Generate random serial prefix: @serial_prefix_lists\n";
	}
	else {
		@serial_prefix_lists = split(/,/, $$config_ref{serial_prefix});
	}

    # Open connections to each autobench host
    foreach $client (keys %$clients_ref) {
    $sock = open_socket($client, $$clients_ref{$client});
    $client_socks{$sock} = $client;
    print STDERR "Opened connection to $client:$$clients_ref{$client}\n"
        if $DEBUG;
    # Make socket non-blocking
    set_non_block($sock);
    push(@socks, $sock);
    }
    
    my $start_time = time() + 5;
    print STDERR "  Command: $httperf_args\n".
         "  Time   : $start_time\n" if $DEBUG;    
    # Send start commands to each client
    foreach $sock (@socks) {
    # Update httperf args about session for each client
    $httperf_args_full = $httperf_args." --cwmp=".$$config_ref{num_sess}.",0,".$$config_ref{sess_type}.",".$serial_prefix_lists[$i++];
    syswrite($sock, "$httperf_args_full\n$start_time\nEND_AB\n");
    print STDERR "Issued start command to: $client_socks{$sock}\n" if $DEBUG;
    $response{$sock} = '';
    }

    # Check that clients have accepted command
    $accepted = 0;
    while (! $accepted) {
    $rin = build_select_bits(@socks);
    $nfound = select($rout = $rin, undef, undef, undef);
    foreach $sock (@socks) {
        $buffer= '';

        if(vec($rout, fileno($sock), 1) 
           && (! ($response{$sock} eq 'TRUE'))) {
        $bytes = sysread($sock, $buffer, 2048);
        if (! defined $bytes) {
            # Probably EAGAIN, don't do nowt
        }
        elsif ($bytes == 0) {
            die "FATAL: client $client_socks{$sock} closed connection";
        }
        else {
            $response{$sock} .= $buffer;
        }
        }
    }
    foreach $sock (@socks) {

        if ($response{$sock} =~ /ACCEPTED\n/) {
        $response{$sock} = 'TRUE';
        print STDERR "$client_socks{$sock} accepted command\n" if $DEBUG;
        }
        if ($response{$sock} eq 'TRUE') {
        $accepted ++;
        }
    }
    $accepted = 0 if ($accepted < scalar(@socks));
    }

    $completed = 0;
    foreach $sock (@socks) {
    $response{$sock} = '';
    }

    while (! $completed) {
    $rin = build_select_bits(@socks);
    $nfound = select($rout = $rin, undef, undef, undef);
    foreach $sock (@socks) {
        if (vec($rout, fileno($sock), 1)) {
        $bytes = sysread($sock, $buffer, 2048);
        if (! defined $bytes) {
            # Probably EAGAIN, don't do nowt
        }
        elsif ($bytes == 0) {
            die "FATAL: client $client_socks{$sock} closed connection";
        }
        else {
            $response{$sock} .= $buffer;
        }
        }
    }
    foreach $sock (@socks) {
        if ($response{$sock} =~ /END_DATA\n/) {
        $completed ++;
        }
        elsif ($response{$sock} =~ /BENCH_FAILED\n/) {
        die "FATAL: client $client_socks{$sock} sent BENCH_FAILED";
        }
    }
    $completed = 0 if ($completed < scalar(@socks));
    }
    
    foreach $sock (@socks) {
    $results_sock{$sock} = parse_response($response{$sock});
    }
    return collate_results(\%results_sock, @socks);

    # testing only 

}

#---------------------------------------------------------------------------
# test_host ($config_ref, $rate, $server, $uri, $port, $clients_ref
sub
test_host 
{
    my ($config_ref, $rate, $server, $uri, $port, $clients_ref) = @_;
    my (%results, $httperf_args, $extra_httperf_opts);
    $extra_httperf_opts = '';

    # Build list of extra httperf config options
    foreach (keys %$config_ref) {
    if ( /^httperf_(.*)$/ ) {
            my $hf_val = $$config_ref{$_};
            $hf_val = ($hf_val eq 'NULL') ? '' : $hf_val; 
        $extra_httperf_opts .= " --".$1." ".$hf_val ;
    }
    }
    $httperf_args = "--server $server --uri \"$uri\"".
    " --timeout ".$$config_ref{timeout}.
    " --rate $rate --port $port $extra_httperf_opts";

	if (defined($$config_ref{max_sess})) {
		my $max_sess = int ($$config_ref{max_sess} / $num_clients);
		$httperf_args = $httperf_args." --max-sessions $max_sess";
	}

	if (defined($$config_ref{forever})) {
		$httperf_args = $httperf_args." --forever";
	}

    %results = %{run_test($httperf_args, $clients_ref, $config_ref)};
	return \%results;
}

#---------------------------------------------------------------------------
# main

# Read config
my %config=get_config($CONFIG_FILE);

# Override config file with options supplied on the command line.
GetOptions( \%config, "host1:s","host2:s","uri1:s","uri2:s","port1:i",
            "port2:i","low_rate:i","high_rate:i","rate_step:i",
            "num_sess:i","timeout:i","quiet","single_host",
            "output_fmt=s","file=s","clients=s","version","debug",
            "serial_prefix=s","sess_type=s","time_gap:i","accurate:i","forever","max_sess:i");
$DEBUG = 1 if (defined $config{debug});

if ($config{version}) {
    print "autobench_admin $VERSION\nCopyright (C) Julian T. J. Midgley <jtjm\@xenoclast.org> 2003\n";
    exit 0;
}

%clients = %{get_clients($config{clients})};
foreach $client (keys %clients) {
    $num_clients ++;
}

if (!defined($config{accurate})) {
	$config{accurate} = 1;
}

# Check number of serial prefix. If not defined, we will generate them randomly.
if (defined($config{serial_prefix})) {
	my @serial_prefix_lists = split(/,/, $config{serial_prefix});

	if (($#serial_prefix_lists + 1) < $num_clients) {
		print "not enough serial prefix for $num_clients clients\n";
		exit 0;
	}
}

if ( $config{output_fmt} eq 'csv' ) {
    $sep = ",";
}
elsif ( $config{output_fmt} eq 'tsv' ) {
    $sep = "\t";
}
else {
    die "Output Format '$config{output_fmt}' not supported";
}

# Set the output stream correctly 
if (defined($config{file})){
    # Filename supplied with --file option, try to open it for writing.
    open(OUT, ">$config{file}") or die "Cannot open $config{file} for writing";
}
else {
	my $date = strftime "%Y%m%d-%H.%M.%S", localtime;
	open(OUT, ">result.$date.$config{num_sess}sess") or open(OUT, ">&STDOUT") or die "Bizarre, cannot connect OUT to STDOUT!";
}

# Print first line of output
# The following is really quite ugly...
# The following is really quite ugly...
    print OUT "dem_req_rate".$sep.
        "time_begin".$sep.
        "time_end".$sep.
        "req_rate".$sep.
        "min_rep_rate".$sep.
        "avg_rep_rate".$sep.
        "max_rep_rate".$sep.
        "stddev_rep_rate".$sep.
		"min_sess_rate".$sep.
		"avg_sess_rate".$sep.
		"max_sess_rate".$sep.
		"stddev_sess_rate".$sep.
		"concurrent_conn".$sep.
        "duration".$sep.
        "sess_life_time".$sep.
        "net_io".$sep.
        "error_total".$sep.
        "error_work_flow".$sep.
        "error_bad_request".$sep.
        "error_no_response".$sep.
        "error_others";

    if ($config{single_host}) {
        print OUT "\n";
    }
    else {
        print OUT $sep."req_rate_$config{host2}".$sep.
            "min_rep_rate_$config{host2}".$sep.
            "avg_rep_rate_$config{host2}".$sep.
            "max_rep_rate_$config{host2}".$sep.
            "stddev_rep_rate_$config{host2}".$sep.
			"min_sess_rate_$config{host2}".$sep.
			"avg_sess_rate_$config{host2}".$sep.
			"max_sess_rate_$config{host2}".$sep.
			"stddev_sess_rate_$config{host2}".$sep.
			"concurrent_conn_$config{host2}".$sep.
			"duration_$config{host2}".$sep.
            "net_io_$config{host2}".$sep.
            "error_total_$config{host2}".$sep.
            "error_work_flow_$config{host2}".$sep.
            "error_bad_request_$config{host2}".$sep.
            "error_no_response_$config{host2}".$sep.
            "error_others_$config{host2}\n";
    }

my $sess_total = $config{num_sess};

for ($curr_rate = $config{low_rate}; $curr_rate <= $config{high_rate}; 
     $curr_rate += $config{rate_step}) {

    my $shared_rate = $curr_rate / $num_clients;
    $config{num_sess} = int ($sess_total / $num_clients);

	undef %res_host1;
	undef %res_host2;

	for my $i (1..$config{accurate}) {
		print STDERR `date`;
		# Test Host 1
		print STDERR "Testing server $config{host1} at rate: $curr_rate\n";

		%res_host = %{test_host (\%config, $shared_rate, $config{host1}, $config{uri1}, $config{port1}, \%clients)};

		foreach $key (keys %res_host) {
			if ($key eq "duration")
			{
				print STDERR "Duration: $res_host{$key}\n";
			}
			if ($key cmp "time_begin" && $key cmp "time_end") {
				$res_host1{$key} += $res_host{$key};
			} else {
				$res_host1{$key} .= $res_host{$key}.",";
			}
		}

		# Calculate request rate
		$res_host1{req_rate} += $res_host{req_num} / $res_host{duration};
    
		# Test Host 2
		unless ( $config{single_host} ) {
			print STDERR "About to test $config{host2} at rate: $curr_rate\n";
			%res_host = %{test_host (\%config, $shared_rate, $config{host2}, $config{uri2}, $config{port2}, \%clients)};

			foreach $key (keys %res_host) {
				if ($key cmp "time_begin" && $key cmp "time_end") {
					$res_host2{$key} += $res_host{$key};
				} else {
					$res_host2{$key} .= $res_host{$key}.",";
				}   

			}

			# Calculate request rate
			$res_host2{req_rate} += $res_host{req_num} / $res_host{duration};
		}

		wait_stable($config{host1}, $config{time_gap}) if $config{time_gap};
	}

	# Calculate the average value of each test result
	foreach $key (keys %res_host1) {
		if (index ($key, "time_")) {
			$res_host1{$key} = $res_host1{$key} / $config{accurate};
		
			# Set the floating precision
			$res_host1{$key} = sprintf "%.3f", $res_host1{$key};
		}
	}

	foreach $key (keys %res_host2) {
		if (index ($key, "time_")) {
		    $res_host2{$key} = $res_host2{$key} / $config{accurate};

		    # Set the floating precision
		     $res_host2{$key} = sprintf "%.3f", $res_host2{$key};
		}
	}       


    # Merge and Display Results
    $dem_req = $curr_rate;
    print OUT $dem_req.$sep.
      $res_host1{time_begin}.$sep.
      $res_host1{time_end}.$sep.
      $res_host1{req_rate}.$sep.
      $res_host1{rep_rate_min}.$sep.
      $res_host1{rep_rate_avg}.$sep.
      $res_host1{rep_rate_max}.$sep.
      $res_host1{rep_rate_stdv}.$sep.
	  $res_host1{sess_rate_min}.$sep.
	  $res_host1{sess_rate_avg}.$sep.
	  $res_host1{sess_rate_max}.$sep.
	  $res_host1{sess_rate_stdv}.$sep.
	  $res_host1{concur_conn}.$sep.
      $res_host1{duration}.$sep.
      $res_host1{sess_life_time}.$sep.
      $res_host1{net_io}.$sep.
      $res_host1{error_total}.$sep.
      $res_host1{error_workflow}.$sep.
      $res_host1{error_badreq}.$sep.
      $res_host1{error_nores}.$sep.
      $res_host1{error_other};

    if ($config{single_host}) {
    print OUT "\n";
    }
    else {
    print OUT $res_host2{time_begin}.$sep.
      $res_host2{time_end}.$sep.
      $res_host2{req_rate}.$sep.
      $res_host2{rep_rate_min}.$sep.
      $res_host2{rep_rate_avg}.$sep.
      $res_host2{rep_rate_max}.$sep.
      $res_host2{rep_rate_stdv}.$sep.
	  $res_host2{sess_rate_min}.$sep.
	  $res_host2{sess_rate_avg}.$sep.
	  $res_host2{sess_rate_max}.$sep.
	  $res_host2{sess_rate_stdv}.$sep.
	  $res_host2{concur_conn}.$sep.
      $res_host2{duration}.$sep.
      $res_host2{sess_life_time}.$sep.
      $res_host2{net_io}.$sep.
      $res_host2{error_total}.$sep.
      $res_host2{error_workflow}.$sep.
      $res_host2{error_badreq}.$sep.
      $res_host2{error_nores}.$sep.
      $res_host2{error_other}."\n";
    }
}

print STDERR "Benchmark complete\n";
